import java.util.*;
/**
 * Этот класс хранит базовое состояние, необходимое алгоритму A* для вычисления
 * путь по карте. Это состояние включает в себя коллекцию " открытых путевых точек "и
 * другую коллекцию "закрытых путевых точек"." Кроме того, этот класс обеспечивает
 * основные операции, необходимые алгоритму поиска пути A* для выполнения его
 * обработка.
 **/
public class AStarState {
    /** Это ссылка на карту, по которой перемещается алгоритм A*. **/
    private Map2D map;
    private Map<Location, Waypoint> Opened = new java.util.HashMap<Location, Waypoint>();
    private Map<Location, Waypoint> Closed = new java.util.HashMap<Location, Waypoint>();


    /**
     * Инициализируйте новый объект состояния для использования алгоритма поиска пути A*.
     **/
    public AStarState(Map2D map)
    {
        if (map == null)
            throw new NullPointerException("map cannot be null");

        this.map = map;
    }

    /** Возвращает карту, по которой перемещается навигатор A*. **/
    public Map2D getMap()
    {
        return map;
    }

    /**
     Эта функция должна проверить все вершины в наборе открытых вершин,
     и после этого она должна вернуть ссылку на вершину с наименьшей общей
     стоимостью. Если в "открытом" наборе нет вершин, функция возвращает
     NULL.
     Не удаляйте вершину из набора после того, как вы вернули ее; просто
     верните ссылку на точку с наименьшей общей стоимость
     **/
    public Waypoint getMinOpenWaypoint()
    {
        if (Opened.size() == 0) return null; //ситуация если в открытом наборе нет вершин
        ArrayList<Waypoint> waypoints = new ArrayList<Waypoint>(Opened.values());
        float mincost = waypoints.get(0).getTotalCost();   //узнаем стоимость вершины
        Waypoint min = waypoints.get(0);
        for (int i = 1; i < waypoints.size(); i++) {       //циклом находим самую менее затратную вершину и возвращаем "ссылку на нее"
            if (waypoints.get(i).getTotalCost() < mincost) {
                min = waypoints.get(i);
                mincost = min.getTotalCost();
            }
        }
        return min;

    }

    /**
     Это самый сложный метод в классе состояний А*. Данный метод
     усложняет то, что он должен добавлять указанную вершину только в том
     случае, если существующая вершина хуже новой. Вот что должен делать этот
     метод:
     Если в наборе «открытых вершин» в настоящее время нет вершины
     для данного местоположения, то необходимо просто добавить новую вершину.
      Если в наборе «открытых вершин» уже есть вершина для этой
     локации, добавьте новую вершину только в том случае, если стоимость пути до
     новой вершины меньше стоимости пути до текущей. (Убедитесь, что
     используете не общую стоимость.) Другими словами, если путь через новую
     вершину короче, чем путь через текущую вершину, замените текущую вершину
     на новую

     **/
    public boolean addOpenWaypoint(Waypoint newWP) {
        if (Opened.get(newWP.getLocation()) == null) {    //тут мы просто добавляем в переменную новую вершину если в открытом наборе до этого не было ее
            Opened.put(newWP.getLocation(), newWP);
            return true;
        } else {
            if (Opened.get(newWP.getLocation()).getPreviousCost() >  //здесь мы сравниваем стоимость старой и новой вершин и если новая выгоднеее переприсваиваем
                    newWP.getPreviousCost()) {
                Opened.put(newWP.getLocation(), newWP);
                return true;

            }
        }
        return false;
    }

    /** Этот метод возвращает количество точек в наборе открытых вершин.   **/
    public int numOpenWaypoints()
    {
        return Opened.size(); //узнаем количество открытой хэш карты - вершины которые еще надо будет обрабатывать алгоритмом
    }


    /**
     Эта функция перемещает вершину из набора «открытых вершин» в набор
     «закрытых вершин». Так как вершины обозначены местоположением, метод
     принимает местоположение вершины.
     **/
    public void closeWaypoint(Location loc)
    {
        Closed.put(loc, Opened.remove(loc)); //Удалите вершину, соответствующую указанному местоположению из набора «открытых вершин».
                                             // Добавьте вершину, которую вы удалили, в набор закрытых вершин.
                                             //Ключом должно являться местоположение точки.
    }

    /**
     Эта функция должна возвращать значение true, если указанное
     местоположение встречается в наборе закрытых вершин, и false в противном
     случае. Так как закрытые вершины хранятся в хэш-карте с расположениями в
     качестве ключевых значений, данный метод достаточно просто в реализации.
     **/
    public boolean isLocationClosed(Location loc)
    {
        if (Closed.containsKey(loc)) return true; //тру если местоположение которое мы передали находится в закрытом хэш коде
        return false;                             //фолс в противоположном случае
    }
}
